<!DOCTYPE HTML>
<html>
<head>
<script src="image-util.js"></script>
<script src="stipple.js"></script>
<script src="solver.js"></script>
<style>
html, body {
  font-family: Tahoma;
  font-size: 90%;
}
</style>
</head>
<body>
<div style="display:flex; align-items: center">
Select an image to process: 
<select id="selection" onChange="changeImage()">
  <option value="./sample-images/paris.jpg">Paris</option>
  <option value="./sample-images/baobabs.jpg">Avenue of Baobabs</option>
  <option value="./sample-images/cup.jpg">Cup</option>
</select>
&nbsp;&nbsp;Stippling Threshold: 
<input id="threshold" style="width: 300px" type="range" min="80" max="100" step="0.25" value="95" onChange="changeThreshold()">
<div id="threshold-value">0.95</div>
</div>
<br>
<canvas id="stage1"></canvas>
<canvas id="stage2"></canvas>
<canvas id="stage3"></canvas>
</body>
<script>

const SIZE = 300;

// Control vars
let currentImage = 'sample-images/paris.jpg';
let threshold = 0.95;


function changeImage() {
  const select = document.getElementById('selection');
  console.log(select.options[select.selectedIndex]);
  currentImage = select.options[select.selectedIndex].value;
  run(currentImage);
}
function changeThreshold() {
  const thresholdSlider = document.getElementById('threshold');
  threshold = +thresholdSlider.value / 100;

  document.getElementById('threshold-value').innerHTML = threshold;
  run(currentImage);
}


const canvasCtx = (id) => {
  const canvas = document.getElementById(id);
  canvas.width = SIZE;
  canvas.height = SIZE;

  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, SIZE, SIZE);
  return ctx;
}

const drawSingleChannel = (ctx, data) => {
  const imageData = ctx.createImageData(SIZE, SIZE);
  for (let i = 0; i < data.length; i ++) {
    const v = data[i] * 255;
    imageData.data[4 * i + 0] = v;
    imageData.data[4 * i + 1] = v;
    imageData.data[4 * i + 2] = v;
    imageData.data[4 * i + 3] = 255;
  }
  ctx.putImageData(imageData, 0 , 0);
}

const drawImage = (ctx, data) => {
  ctx.putImageData(data, 0 , 0);
}


let drawPath;
let counter = 0;
let counterInc = 3;

function sketch(ctx) {
  const skip = 1;

  if (counter + skip >= drawPath.length - 1) {
    ctx.clearRect(0, 0, SIZE, SIZE);
    counter = 0;
  }
  ctx.lineWidth = 0.1;
  ctx.strokeStyle = '#AAA';

  for (let i = 0; i < counter; i += skip) {
    // const d = Math.sqrt(
    //   (drawPath[i + skip].x - drawPath[i].x) * (drawPath[i + skip].x - drawPath[i].x) +
    //   (drawPath[i + skip].y - drawPath[i].y) * (drawPath[i + skip].y - drawPath[i].y));
    // if (d > 30) continue;

    ctx.beginPath();
    ctx.moveTo(drawPath[i].x, drawPath[i].y);
    ctx.lineTo(drawPath[i + skip].x, drawPath[i + skip].y);
    ctx.closePath();
    ctx.stroke();
  }
  counter += counterInc;
  requestAnimationFrame(() => {
    sketch(ctx);
  });
}

async function run(imageName) {
  // Init
  const stage1Ctx = canvasCtx('stage1');
  const stage2Ctx = canvasCtx('stage2');
  const stage3Ctx = canvasCtx('stage3');

  // Load
  const image = await ImageUtil.loadImage(imageName, { width: SIZE, height: SIZE });

  // Greyscale
  const greyScale = ImageUtil.flatten(image.data, { width: SIZE, height: SIZE });

  // Invert
  const inverted = ImageUtil.invert(greyScale);

  // Blur
  const blur = ImageUtil.convolve(inverted, { width: SIZE, height: SIZE, channels: 1 }, 
    // ImageUtil.blur5x5
    ImageUtil.blurGaussian
  );

  // Dodge
  const dodge = ImageUtil.dodge(blur, greyScale);

  // Stippling
  const stippledData = stipple(dodge, SIZE, SIZE, { 
    sampleSize: 1,
    // sampleThreshold: 0.85 // tree
    sampleThreshold: threshold
  });

  // Stage-1
  // drawSingleChannel(stage1Ctx, greyScale);
  drawImage(stage1Ctx, image);

  // Stage-2
  drawSingleChannel(stage2Ctx, blur);

  // Stage-3
  drawPath = nearestNeighbour(stippledData.result);

  requestAnimationFrame(() => {
    sketch(stage3Ctx);
  });
}

run(currentImage);
</script>
</html>
